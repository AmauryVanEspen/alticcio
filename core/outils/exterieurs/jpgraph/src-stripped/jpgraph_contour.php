<?php
 require_once('jpgraph_meshinterpolate.inc.php'); define('HORIZ_EDGE',0); define('VERT_EDGE',1); class Contour { private $dataPoints = array(); private $nbrCols=0,$nbrRows=0; private $horizEdges = array(), $vertEdges=array(); private $isobarValues = array(); private $stack = null; private $isobarCoord = array(); private $nbrIsobars = 10, $isobarColors = array(); private $invert = true; private $highcontrast = false, $highcontrastbw = false; function __construct($aMatrix,$aIsobars=10, $aColors=null) { $this->nbrRows = count($aMatrix); $this->nbrCols = count($aMatrix[0]); $this->dataPoints = $aMatrix; if( is_array($aIsobars) ) { $this->nbrIsobars = count($aIsobars); $this->isobarValues = $aIsobars; } else { $this->nbrIsobars = $aIsobars; list($min,$max) = $this->getMinMaxVal(); $stepSize = ($max-$min) / $aIsobars ; $isobar = $min+$stepSize/2; for ($i = 0; $i < $aIsobars; $i++) { $this->isobarValues[$i] = $isobar; $isobar += $stepSize; } } if( $aColors !== null && count($aColors) > 0 ) { if( !is_array($aColors) ) { JpGraphError::RaiseL(28001); } if( count($aColors) != count($this->isobarValues) ) { JpGraphError::RaiseL(28002); } $this->isobarColors = $aColors; } } function SetInvert($aFlg=true) { $this->invert = $aFlg; } function getMinMaxVal() { $min = $this->dataPoints[0][0]; $max = $this->dataPoints[0][0]; for ($i = 0; $i < $this->nbrRows; $i++) { if( ($mi=min($this->dataPoints[$i])) < $min ) $min = $mi; if( ($ma=max($this->dataPoints[$i])) > $max ) $max = $ma; } return array($min,$max); } function resetEdgeMatrices() { for ($k = 0; $k < 2; $k++) { for ($i = 0; $i <= $this->nbrRows; $i++) { for ($j = 0; $j <= $this->nbrCols; $j++) { $this->edges[$k][$i][$j] = false; } } } } function isobarHCrossing($aRow,$aCol,$aIsobar) { if( $aCol >= $this->nbrCols-1 ) { JpGraphError::RaiseL(28003,$aCol); } if( $aRow >= $this->nbrRows ) { JpGraphError::RaiseL(28004,$aRow); } $v1 = $this->dataPoints[$aRow][$aCol]; $v2 = $this->dataPoints[$aRow][$aCol+1]; return ($aIsobar-$v1)*($aIsobar-$v2) < 0 ; } function isobarVCrossing($aRow,$aCol,$aIsobar) { if( $aRow >= $this->nbrRows-1) { JpGraphError::RaiseL(28005,$aRow); } if( $aCol >= $this->nbrCols ) { JpGraphError::RaiseL(28006,$aCol); } $v1 = $this->dataPoints[$aRow][$aCol]; $v2 = $this->dataPoints[$aRow+1][$aCol]; return ($aIsobar-$v1)*($aIsobar-$v2) < 0 ; } function determineIsobarEdgeCrossings($aIsobar) { $ib = $this->isobarValues[$aIsobar]; for ($i = 0; $i < $this->nbrRows-1; $i++) { for ($j = 0; $j < $this->nbrCols-1; $j++) { $this->edges[HORIZ_EDGE][$i][$j] = $this->isobarHCrossing($i,$j,$ib); $this->edges[VERT_EDGE][$i][$j] = $this->isobarVCrossing($i,$j,$ib); } } for ($i = 0; $i < $this->nbrRows-1; $i++) { $this->edges[VERT_EDGE][$i][$j] = $this->isobarVCrossing($i,$this->nbrCols-1,$ib); } for ($j = 0; $j < $this->nbrCols-1; $j++) { $this->edges[HORIZ_EDGE][$i][$j] = $this->isobarHCrossing($this->nbrRows-1,$j,$ib); } } function getCrossingCoord($aRow,$aCol,$aEdgeDir,$aIsobarVal) { if( $aEdgeDir == HORIZ_EDGE ) { $d = abs($this->dataPoints[$aRow][$aCol] - $this->dataPoints[$aRow][$aCol+1]); if( $d > 0.001 ) { $xcoord = $aCol + abs($aIsobarVal - $this->dataPoints[$aRow][$aCol]) / $d; } else { $xcoord = $aCol; } $ycoord = $aRow; } else { $d = abs($this->dataPoints[$aRow][$aCol] - $this->dataPoints[$aRow+1][$aCol]); if( $d > 0.001 ) { $ycoord = $aRow + abs($aIsobarVal - $this->dataPoints[$aRow][$aCol]) / $d; } else { $ycoord = $aRow; } $xcoord = $aCol; } if( $this->invert ) { $ycoord = $this->nbrRows-1 - $ycoord; } return array($xcoord,$ycoord); } function adjustDataPointValues() { $ni = count($this->isobarValues); for ($k = 0; $k < $ni; $k++) { $ib = $this->isobarValues[$k]; for ($row = 0 ; $row < $this->nbrRows-1; ++$row) { for ($col = 0 ; $col < $this->nbrCols-1; ++$col ) { if( abs($this->dataPoints[$row][$col] - $ib) < 0.0001 ) { $this->dataPoints[$row][$col] += $this->dataPoints[$row][$col]*0.001; } } } } } function UseHighContrastColor($aFlg=true,$aBW=false) { $this->highcontrast = $aFlg; $this->highcontrastbw = $aBW; } function CalculateColors() { if ( $this->highcontrast ) { if ( $this->highcontrastbw ) { for ($ib = 0; $ib < $this->nbrIsobars; $ib++) { $this->isobarColors[$ib] = 'black'; } } else { $step = round(255/($this->nbrIsobars-1)); for ($ib = 0; $ib < $this->nbrIsobars; $ib++) { $this->isobarColors[$ib] = array($ib*$step, 50, 255-$ib*$step); } } } else { $n = $this->nbrIsobars; $v = 0; $step = 1 / ($this->nbrIsobars-1); for ($ib = 0; $ib < $this->nbrIsobars; $ib++) { $this->isobarColors[$ib] = RGB::GetSpectrum($v); $v += $step; } } } function getIsobars() { $this->adjustDataPointValues(); for ($isobar = 0; $isobar < $this->nbrIsobars; $isobar++) { $ib = $this->isobarValues[$isobar]; $this->resetEdgeMatrices(); $this->determineIsobarEdgeCrossings($isobar); $this->isobarCoord[$isobar] = array(); $ncoord = 0; for ($row = 0 ; $row < $this->nbrRows-1; ++$row) { for ($col = 0 ; $col < $this->nbrCols-1; ++$col ) { $n = 0; if ( $this->edges[HORIZ_EDGE][$row][$col] ) $neigh[$n++] = array($row, $col, HORIZ_EDGE); if ( $this->edges[HORIZ_EDGE][$row+1][$col] ) $neigh[$n++] = array($row+1,$col, HORIZ_EDGE); if ( $this->edges[VERT_EDGE][$row][$col] ) $neigh[$n++] = array($row, $col, VERT_EDGE); if ( $this->edges[VERT_EDGE][$row][$col+1] ) $neigh[$n++] = array($row, $col+1,VERT_EDGE); if ( $n == 2 ) { $n1=0; $n2=1; $this->isobarCoord[$isobar][$ncoord++] = array( $this->getCrossingCoord($neigh[$n1][0],$neigh[$n1][1],$neigh[$n1][2],$ib), $this->getCrossingCoord($neigh[$n2][0],$neigh[$n2][1],$neigh[$n2][2],$ib) ); } elseif ( $n == 4 ) { $midval = ($this->dataPoints[$row][$col]+$this->dataPoints[$row][$col+1]+$this->dataPoints[$row+1][$col]+$this->dataPoints[$row+1][$col+1])/4; $v = $this->dataPoints[$row][$col]; if( $midval == $ib ) { $n1=0; $n2=1; $n3=2; $n4=3; } elseif ( ($midval > $ib && $v > $ib) || ($midval < $ib && $v < $ib) ) { $n1=0; $n2=3; $n3=2; $n4=1; } elseif ( ($midval > $ib && $v < $ib) || ($midval < $ib && $v > $ib) ) { $n1=0; $n2=2; $n3=3; $n4=1; } $this->isobarCoord[$isobar][$ncoord++] = array( $this->getCrossingCoord($neigh[$n1][0],$neigh[$n1][1],$neigh[$n1][2],$ib), $this->getCrossingCoord($neigh[$n2][0],$neigh[$n2][1],$neigh[$n2][2],$ib) ); $this->isobarCoord[$isobar][$ncoord++] = array( $this->getCrossingCoord($neigh[$n3][0],$neigh[$n3][1],$neigh[$n3][2],$ib), $this->getCrossingCoord($neigh[$n4][0],$neigh[$n4][1],$neigh[$n4][2],$ib) ); } } } } if( count($this->isobarColors) == 0 ) { $this->CalculateColors(); } return array( $this->isobarCoord, $this->isobarValues, $this->isobarColors ); } } class ContourPlot extends Plot { private $contour, $contourCoord, $contourVal, $contourColor; private $nbrCountours = 0 ; private $dataMatrix = array(); private $invertLegend = false; private $interpFactor = 1; private $flipData = false; private $isobar = 10; private $showLegend = false; private $highcontrast = false, $highcontrastbw = false; private $manualIsobarColors = array(); function __construct($aDataMatrix, $aIsobar=10, $aFactor=1, $aInvert=false, $aIsobarColors=array()) { $this->dataMatrix = $aDataMatrix; $this->flipData = $aInvert; $this->isobar = $aIsobar; $this->interpFactor = $aFactor; if ( $this->interpFactor > 1 ) { if( $this->interpFactor > 5 ) { JpGraphError::RaiseL(28007); } $ip = new MeshInterpolate(); $this->dataMatrix = $ip->Linear($this->dataMatrix, $this->interpFactor); } $this->contour = new Contour($this->dataMatrix,$this->isobar,$aIsobarColors); if( is_array($aIsobar) ) $this->nbrContours = count($aIsobar); else $this->nbrContours = $aIsobar; } function SetInvert($aFlg=true) { $this->flipData = $aFlg; } function SetIsobarColors($aColorArray) { $this->manualIsobarColors = $aColorArray; } function ShowLegend($aFlg=true) { $this->showLegend = $aFlg; } function Invertlegend($aFlg=true) { $this->invertLegend = $aFlg; } function Min() { return array(0,0); } function Max() { return array(count($this->dataMatrix[0])-1,count($this->dataMatrix)-1); } function Legend($aGraph) { if( ! $this->showLegend ) return; if( $this->invertLegend ) { for ($i = 0; $i < $this->nbrContours; $i++) { $aGraph->legend->Add(sprintf('%.1f',$this->contourVal[$i]), $this->contourColor[$i]); } } else { for ($i = $this->nbrContours-1; $i >= 0 ; $i--) { $aGraph->legend->Add(sprintf('%.1f',$this->contourVal[$i]), $this->contourColor[$i]); } } } function PreScaleSetup($aGraph) { $xn = count($this->dataMatrix[0])-1; $yn = count($this->dataMatrix)-1; $aGraph->xaxis->scale->Update($aGraph->img,0,$xn); $aGraph->yaxis->scale->Update($aGraph->img,0,$yn); $this->contour->SetInvert($this->flipData); list($this->contourCoord,$this->contourVal,$this->contourColor) = $this->contour->getIsobars(); } function UseHighContrastColor($aFlg=true,$aBW=false) { $this->highcontrast = $aFlg; $this->highcontrastbw = $aBW; $this->contour->UseHighContrastColor($this->highcontrast,$this->highcontrastbw); } function Stroke($img,$xscale,$yscale) { if( count($this->manualIsobarColors) > 0 ) { $this->contourColor = $this->manualIsobarColors; if( count($this->manualIsobarColors) != $this->nbrContours ) { JpGraphError::RaiseL(28002); } } $img->SetLineWeight($this->line_weight); for ($c = 0; $c < $this->nbrContours; $c++) { $img->SetColor( $this->contourColor[$c] ); $n = count($this->contourCoord[$c]); $i = 0; while ( $i < $n ) { list($x1,$y1) = $this->contourCoord[$c][$i][0]; $x1t = $xscale->Translate($x1); $y1t = $yscale->Translate($y1); list($x2,$y2) = $this->contourCoord[$c][$i++][1]; $x2t = $xscale->Translate($x2); $y2t = $yscale->Translate($y2); $img->Line($x1t,$y1t,$x2t,$y2t); } } } } ?>
