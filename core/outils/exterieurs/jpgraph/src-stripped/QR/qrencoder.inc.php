<?php
 require_once('qrexception.inc.php'); require_once('qr-utils.inc.php'); require_once('reed-solomon.inc.php'); require_once('qrcapacity.inc.php'); require_once('qrlayout.inc.php'); require_once('backend.inc.php'); class QREncoder { const MODE_ECI = 0; const MODE_NUMERIC = 1; const MODE_ALPHANUM = 2; const MODE_BYTE = 3; const MODE_KANJI = 4; const MODE_TERMINATOR = 8; const MODE_STRUCTAPPEND = 5; const MODE_FNC1_1 = 6; const MODE_FNC1_2 = 7; const RSPrimitivePol = 0x11d; private $iDbgLevel = -1 ; public $iFinalBitArray = array(); private $iSymbolBitArray = array(), $iSymbolBitArrayLen = 0; private $iCodeWords = array(); private $iFinalCodewordSequence = array(); private $iDecodedChars = array(); private $iDecodeInfo = array(), $iEncodeInfo = array(), $iInfo = array(), $iErrDebugInfostr = ""; private $iGeneralInfo = ""; private $iData = null, $iOrigData = null; private $iVersion = -1, $iOrigVersion = -1; private $iErrLevel = QRCapacity::ErrM; private $iAlphaNumTable = array(); private $iAlphaNumInvTable = array(); private $iModeIndicator = array( QREncoder::MODE_ECI => array(0, 1, 1, 1), QREncoder::MODE_NUMERIC => array(0, 0, 0, 1), QREncoder::MODE_ALPHANUM => array(0, 0, 1, 0), QREncoder::MODE_BYTE => array(0, 1, 0, 0), QREncoder::MODE_KANJI => array(1, 0, 0, 0), QREncoder::MODE_STRUCTAPPEND => array(0, 0, 1, 1), QREncoder::MODE_FNC1_1 => array(0, 1, 0, 1), QREncoder::MODE_FNC1_2 => array(1, 0, 0, 1), QREncoder::MODE_TERMINATOR => array(0, 0, 0, 0)); private $iModeIndicatorString = array( QREncoder::MODE_ECI => 'MODE_ECI', QREncoder::MODE_NUMERIC => 'MODE_NUMERIC', QREncoder::MODE_ALPHANUM => 'MODE_ALPHANUM', QREncoder::MODE_BYTE => 'MODE_BYTE', QREncoder::MODE_KANJI => 'MODE_KANJI', QREncoder::MODE_STRUCTAPPEND => 'MODE_STRUCTAPPEND', QREncoder::MODE_FNC1_1 => 'MODE_FNC1_1', QREncoder::MODE_FNC1_2 => 'MODE_FNC1_2', QREncoder::MODE_TERMINATOR => 'MODE_TERMINATOR'); private $iNbrModes = 9; private $iManualEncoding = false; private $iQRCapacity = null; private $iQRMask = null; private $iSelectedLayoutMaskIdx = -1; function __construct($aVersion = -1, $aErrLevel = QRCapacity::ErrM) { $this->SetSize($aVersion); if( $aErrLevel < 0 ) { if( $aVersion > 30 ) { $aErrLevel = QRCapacity::ErrH; $this->iGeneralInfo .= "Automatically set error level to H\n"; } elseif( $aVersion > 20 ) { $aErrLevel = QRCapacity::ErrQ; $this->iGeneralInfo .= "Automatically set error level to Q\n"; } else { $aErrLevel = QRCapacity::ErrM; $this->iGeneralInfo .= "Automatically set error level to M\n"; } } $this->iErrLevel = $aErrLevel; for($i = 0; $i < 10; ++$i) { $this->iAlphaNumTable[ord('0') + $i] = $i; } for($i = 0; $i < 26; ++$i) { $this->iAlphaNumTable[ord('A') + $i] = 10 + $i; } $punct = array(ord(' ') => 36, ord('$') => 37, ord('%') => 38, ord('*') => 39, ord('+') => 40, ord('-') => 41, ord('.') => 42, ord('/') => 43, ord(':') => 44); $this->iAlphaNumTable = $this->iAlphaNumTable + $punct; foreach($this->iAlphaNumTable as $key => $val) { $this->iAlphaNumInvTable[$val] = $key; } $this->iQRCapacity = QRCapacity::getInstance(); $this->iQRMask = QRMask::getInstance(); } function __toString() { $r = ''; $rb = implode($this->iSymbolBitArray); $r .= str_repeat('-',40)."\nEncodation details:\n".str_repeat('-',40)."\n\n"; $errStr = array('L', 'M', 'Q', 'H'); $r .= 'QR Version: ' . $this->iVersion . '-' . $errStr[$this->iErrLevel] . "\n"; $r .= 'Data capacity: ' . $this->iQRCapacity->getNumData($this->iVersion, $this->iErrLevel) . "\n"; $r .= 'Error codewords: ' . $this->iQRCapacity->getNumErr($this->iVersion, $this->iErrLevel) . "\n"; $r .= 'Layout mask used (index): '.$this->iSelectedLayoutMaskIdx . "\n"; if( is_string($this->iOrigData) ) { $data = 'Input string: '.$this->iOrigData; } else { $data = "Input strings (manual encodation schemas) :\n"; $n = count($this->iOrigData); for($i=0; $i < $n; $i++) { $data .= " (" . $this->iOrigData[$i][0] . " : " . $this->iOrigData[$i][1] . ")\n" ; } } $r .= $data . "\n\n"; $r .= "General info:\n-------------\n"; $r .= $this->iGeneralInfo . "\n\n"; $rb = str_split($rb, 50); $n = count($rb); if( $this->iDbgLevel >= 1 ) { $r .= "Encoding process:\n"; $r .= $this->encodeToString() . "\n"; $r .= "Output bits excluding pad byte(s) (len=" . $this->iSymbolBitArrayLen . "):\n"; for($i = 0; $i < $n; ++$i) { $r .= $rb[$i] . "\n"; } } if( $this->iDbgLevel >= 2 ) { $n = count($this->iCodeWords); $cw = ''; for($i = 0; $i < $n; ++$i) { $cw .= sprintf('%08s (0x%02x)', decbin($this->iCodeWords[$i]), $this->iCodeWords[$i]); if(($i + 1) % 4 == 0) { $cw .= ",\n"; } elseif($i < $n-1) { $cw .= ', '; } } $r .= "\nCodewords from bit sequence (len=$n):\n" . $cw . "\n"; $r .= "Addition of Error correction code blocks.\n"; $r .= $this->iErrDebugInfostr; } return $r; } function SetSize($aVersion) { if( $aVersion != -1 && $aVersion < 1 || $aVersion > 40 ) { throw new QRExceptionL(1400,$aVersion); } $this->iVersion = $aVersion; $this->iOrigVersion = $aVersion; } function SetDebugLevel( $aDbgLevel=FALSE ) { if( $aDbgLevel !== FALSE ) $this->iDbgLevel = $aDbgLevel; } function Enc($aData, $aManual = false) { if( empty($aData) ) { throw new QRExceptionL(1401); } $this->iOrigData = $aData ; $this->iData = ''; $this->iVersion = $this->iOrigVersion; $this->iFinalBitArray = array(); $this->iSymbolBitArray = array(); $this->iSymbolBitArrayLen = 0; $this->iCodeWords = array(); $this->iFinalCodewordSequence = array(); if(is_array($aData)) { if($aManual == false) { throw new QRExceptionL(1402); } if(!is_array($aData[0])) { throw new QRExceptionL(1403); } $n = count($aData); for($i = 0; $i < $n; ++$i) { $nn = count($aData[$i]); if($nn != 2) { throw new QRExceptionL(1404); } if(!is_numeric($aData[$i][0]) || !is_string($aData[$i][1])) { throw new QRExceptionL(1405,$i); } } } elseif(!is_string($aData)) { throw new QRExceptionL(1406); } elseif($aManual) { throw new QRExceptionL(1407); } if( $this->iVersion <= 0 ) { $this->iGeneralInfo .= "Automatic determination of the QR Version\n"; if( is_string($aData) ) { $guess_codewordlen = floor(strlen($aData) / 2.5); } else { $n = count($aData); $guess_codewordlen = 0; for($i=0; $i < $n; $i++) { $guess_codewordlen += floor(strlen($aData[$i][1]) / 2.5); } } $vers = 0; do { ++$vers; $nbrdata = $this->iQRCapacity->getNumData($vers, $this->iErrLevel); } while( $nbrdata <= $guess_codewordlen ) ; do { $this->iVersion = $vers; $this->iData = $aData; $this->iSymbolBitArray = array(); $this->iSymbolBitArrayLen = 0; $this->iCodeWords = array(); $this->iEncodeInfo = array(); $this->iGeneralInfo .= " ... Trying version $vers with "; if($aManual) { $this->iGeneralInfo .= " manual encodation \n"; $this->doManual(); } else { $this->iGeneralInfo .= " automatic encodation \n"; $this->doAuto(); } $this->bitPadSymbols(); $this->splitInBytes(); $nbrdata = $this->iQRCapacity->getNumData($vers, $this->iErrLevel); $dlen = count($this->iCodeWords); ++$vers; } while ($vers <= 40 && $nbrdata < $dlen); if($nbrdata < $dlen) { throw new QRExceptionL(1408); } } else { $this->iGeneralInfo .= "Using manual specified version = {$this->iVersion} with "; $this->iData = $aData; if($aManual) { $this->iGeneralInfo .= " manual encodation \n"; $this->doManual(); } else { $this->iGeneralInfo .= " automatic encodation \n"; $this->doAuto(); } $this->bitPadSymbols(); $this->splitInBytes(); $nbrdata = $this->iQRCapacity->getNumData($this->iVersion, $this->iErrLevel); $dlen = count($this->iCodeWords); if($dlen > $nbrdata) { throw new QRExceptionL(1409,$this->iVersion); } } $this->addPadCodewords(); $this->addErrorCorrection(); $l = new QRMatrixLayout($this->iVersion,$this->iErrLevel); $l->SetDebugLevel($this->iDbgLevel); $l->placeBitStream($this->iFinalBitArray); $l->selectApplyMask(); $this->iSelectedLayoutMaskIdx = $l->iMaskIdx; $l->addVersionInfo(); $l->flatten(); return $l; } function addErrorCorrection() { $blks = $this->iQRCapacity->getBlockStructure($this->iVersion, $this->iErrLevel); $ntype = count($blks); $this->iInfo = array(); $blocks = array(); $dataIdx = 0; $availableCodewords = count($this->iCodeWords); $this->iErrDebugInfostr = ''; $blockoffset = 0; $blockinfo = array(); $totalwords = 0; if($ntype == 1 || $ntype == 2) { for($k = 0; $k < $ntype;++$k) { $nbrBlocks = $blks[$k][0]; $nbrWordsInBlock = $blks[$k][1][0]; $nbrDataInBlock = $blks[$k][1][1]; $nbrErrInBlock = $blks[$k][1][2]; $rs = new ReedSolomon($nbrErrInBlock, QREncoder::RSPrimitivePol); for($i = 0; $i < $nbrBlocks; ++$i) { for($j = 0; $j < $nbrDataInBlock; ++$j) { if($dataIdx >= $availableCodewords) { throw new QRExceptionL(1410); } $blocks[$i + $blockoffset][$j] = $this->iCodeWords[$dataIdx++]; } $blockinfo[$i + $blockoffset] = array($nbrWordsInBlock, $nbrDataInBlock, $nbrErrInBlock); $rs->append($blocks[$i + $blockoffset]); $totalwords += count($blocks[$i + $blockoffset]); $this->iErrDebugInfostr .= "\n=============\nSymbol block: Type=$k, number=" . ($i + 1) . "/$nbrBlocks (Tot=$nbrWordsInBlock, Data=$nbrDataInBlock, Err=$nbrErrInBlock)\n=============\n"; $err = 0; for($j = 0; $j < $nbrWordsInBlock; ++$j) { $fmt = '%08s (%02x)'; $this->iErrDebugInfostr .= sprintf($fmt, decbin($blocks[$i + $blockoffset][$j]), $blocks[$i + $blockoffset][$j]); if($j < $nbrWordsInBlock-1) $this->iErrDebugInfostr .= ', '; if($j == $nbrDataInBlock-1) { $this->iErrDebugInfostr .= "\nError correction word in block:"; } if($j >= $nbrDataInBlock) { ++$err; if($err % 4 == 0) $this->iErrDebugInfostr .= "\n"; } elseif((($j + 1) % 4 == 0) || ($j == $nbrDataInBlock-1) ) { $this->iErrDebugInfostr .= "\n"; } } $this->iErrDebugInfostr .= "\n"; } $blockoffset += $nbrBlocks; } } else { throw new QRExceptionL(1411); } $totalNbrOfBlocks = $blockoffset; $this->iFinalCodewordSequence = array(); $idx = 0; $cwidx = 0; while($idx < $availableCodewords) { for($i = 0; $i < $totalNbrOfBlocks; ++$i) { if($cwidx < $blockinfo[$i][1]) $this->iFinalCodewordSequence[$idx++] = $blocks[$i][$cwidx]; } ++$cwidx; } $erridx = 0; while($erridx < $nbrErrInBlock) { for($i = 0; $i < $totalNbrOfBlocks; ++$i) { $this->iFinalCodewordSequence[$idx++] = $blocks[$i][ $blockinfo[$i][1] + $erridx ]; } ++$erridx; } $n = count($this->iFinalCodewordSequence); if($totalwords != $n) { throw new QRExeption('Internal error: Number of total codewords does not match after split!!'); } $this->iFinalBitArray = array(); Utils::ByteArray2Bits($this->iFinalCodewordSequence, $this->iFinalBitArray); $this->iErrDebugInfostr .= "\n=========== INTERLEAVED CODE SEQUENCE (Total=$n =============\n"; for($i = 0; $i < $n; ++$i) { $v = $this->iFinalCodewordSequence[$i]; $this->iErrDebugInfostr .= sprintf($fmt, decbin($v), $v); if($i < $n-1) $this->iErrDebugInfostr .= ', '; if(($i + 1) % 4 == 0) $this->iErrDebugInfostr .= "\n"; } $this->iErrDebugInfostr .= "\n"; } function addPadCodewords() { $capacity = $this->iQRCapacity->getNumData($this->iVersion, $this->iErrLevel); $nbrPad = $capacity - count($this->iCodeWords); if($nbrPad < 0) { throw new QRExceptionL(1412); } $pads = array('11101100', '00010001'); for($i = 0; $i < $nbrPad; ++$i) { $this->pushEncodeInfo(8, bindec($pads[$i % 2]), 'PAD_BYTE'); $this->iCodeWords[] = bindec($pads[$i % 2]); } } function bitPadSymbols() { if ($this->iSymbolBitArrayLen % 8 > 0) { $n = 8 - ($this->iSymbolBitArrayLen % 8); $fill = array_fill(0, $n, 0); $this->iSymbolBitArray = array_merge($this->iSymbolBitArray, $fill); $this->iSymbolBitArrayLen += $n; $this->pushEncodeInfo($n, str_repeat('0', $n), 'PAD_BITS'); } } function splitInBytes() { $this->iCodeWords = array(); if(count($this->iSymbolBitArray) % 8 > 0) { throw new QRExceptionL(1413); } $this->iCodeWords = array_chunk($this->iSymbolBitArray, 8); $this->iCodeWords = array_map('implode', $this->iCodeWords); $this->iCodeWords = array_map('bindec', $this->iCodeWords); } function decodeToString() { $r = sprintf("%-8s%-15s%-15s%-20s\n", 'Length', 'Bits', 'Value', 'Comment'); $r .= str_repeat('-', 65) . "\n"; for($i = 0; $i < $n; ++$i) { $b = sprintf('%0' . $this->iDecodeInfo[$i][0] . 's', decbin($this->iDecodeInfo[$i][1])); $r .= sprintf("%02s      %-15s%-15s%-20s\n", $this->iDecodeInfo[$i][0], $b, $this->iDecodeInfo[$i][1], $this->iDecodeInfo[$i][2]); } return $r; } function encodeToString() { $n = count($this->iEncodeInfo); $r = sprintf("%-8s%-25s%-20s\n", 'Length', 'Value', 'Comment'); $r .= str_repeat('-', 65) . "\n"; for($i = 0; $i < $n; ++$i) { $r .= sprintf("%02s      %-28s%-20s\n", $this->iEncodeInfo[$i][0], $this->iEncodeInfo[$i][1], $this->iEncodeInfo[$i][2]); } return $r; } function pushDecodeInfo($aBitLen, $aVal, $aComment) { $this->iDecodeInfo[] = array($aBitLen, $aVal, $aComment); } function pushEncodeInfo($aBitLen, $aVal, $aComment) { $this->iEncodeInfo[] = array($aBitLen, $aVal, $aComment); } function pushInfo($aBitLen, $aVal, $aComment) { $this->iInfo[] = array($aBitLen, $aVal, $aComment); } function getCountBits($aMode) { $version = $this->iVersion; $cntBits0109 = array( QREncoder::MODE_NUMERIC => 10, QREncoder::MODE_ALPHANUM => 9, QREncoder::MODE_BYTE => 8, QREncoder::MODE_KANJI => 8, QREncoder::MODE_TERMINATOR => 0 ); $cntBits1026 = array( QREncoder::MODE_NUMERIC => 12, QREncoder::MODE_ALPHANUM => 11, QREncoder::MODE_BYTE => 16, QREncoder::MODE_KANJI => 10, QREncoder::MODE_TERMINATOR => 0 ); $cntBits2740 = array( QREncoder::MODE_NUMERIC => 14, QREncoder::MODE_ALPHANUM => 13, QREncoder::MODE_BYTE => 16, QREncoder::MODE_KANJI => 12, QREncoder::MODE_TERMINATOR => 0 ); if ($version >= 1 && $version <= 9) return $cntBits0109[$aMode]; elseif($version >= 10 && $version <= 26) return $cntBits1026[$aMode]; elseif($version >= 27 && $version <= 40) return $cntBits2740[$aMode]; else { throw new QRExceptionL(1414,$version); } } function doManual() { $nchunks = count($this->iData); $originalData = $this->iData; for($i = 0; $i < $nchunks; ++$i) { $encoding = $originalData[$i][0]; $this->iData = new DataStorage($originalData[$i][1]); switch($encoding) { case QREncoder::MODE_NUMERIC: $digitsleft = $this->iData->Remaining(DataStorage::DIGIT); if( $digitsleft > 0 ) $this->encodeNumeric(); else { throw new QRExceptionL(1415); } break; case QREncoder::MODE_ALPHANUM: $alnumleft = $this->iData->Remaining(DataStorage::ALPHANUM); if( $alnumleft > 0 ) $this->encodeAlphaNum(); else { throw new QRExceptionL(1416); } break; case QREncoder::MODE_BYTE: $byteleft = $this->iData->Remaining(DataStorage::BYTE); if( $byteleft > 0 ) $this->encodeByte(); else { throw new QRExceptionL(1417); } break; default: throw new QRExceptionL(1418,$encoding); break; } } if( !$this->iData->isEnd() ) { throw new QRExceptionL(1419); } $this->PutBitSequence($this->iModeIndicator[QREncoder::MODE_TERMINATOR]); $this->pushEncodeInfo(4, implode($this->iModeIndicator[QREncoder::MODE_TERMINATOR]), "MODE_TERMINATOR"); } function doAuto() { $this->iData = new DataStorage($this->iData); $nbrdigits = $this->iData->Remaining(DataStorage::DIGIT); $nbralpha = $this->iData->Remaining(DataStorage::ALPHA); $nbrbyte = $this->iData->Remaining(DataStorage::BYTEUNIQUE); if( $nbrbyte > 0 ) $currentEncoding = QREncoder::MODE_BYTE; elseif( $nbrdigits >= 7 ) $currentEncoding = QREncoder::MODE_NUMERIC; else $currentEncoding = QREncoder::MODE_ALPHANUM; while( $currentEncoding != QREncoder::MODE_TERMINATOR ) { switch($currentEncoding) { case QREncoder::MODE_NUMERIC: $currentEncoding = $this->encodeNumeric(); break; case QREncoder::MODE_ALPHANUM: $currentEncoding = $this->encodeAlphaNum(false); break; case QREncoder::MODE_BYTE: $currentEncoding = $this->encodeByte(false); break; case QREncoder::MODE_KANJI: throw new QRExceptionL(1420); break; default: throw new QRExceptionL(1421); } } if( !$this->iData->isEnd() ) { throw new QRExceptionL(1422); } $this->PutBitSequence($this->iModeIndicator[QREncoder::MODE_TERMINATOR]); $this->pushEncodeInfo(4, implode($this->iModeIndicator[QREncoder::MODE_TERMINATOR]), "MODE_TERMINATOR"); } function encodeNumeric() { $cnt = 0; $bits = array(); $this->iInfo = array(); $digitsleft = $this->iData->Remaining(DataStorage::DIGIT); while( $digitsleft > 0 ) { $tmpbits = array(); if ($digitsleft >= 3) { $val = ($d1 = $this->iData->Get()) * 100; $val += ($d2 = $this->iData->Get()) * 10; $val += ($d3 = $this->iData->Get()); Utils::Word2Bits($val, $tmpbits, 10); $cnt += 3; $this->pushInfo(10, $val, "3 digits ($d1,$d2,$d3) in MODE_NUMERIC"); } elseif ($digitsleft == 2) { $val = ($d1 = $this->iData->Get()) * 10; $val += ($d2 = $this->iData->Get()); Utils::Word2Bits($val, $tmpbits, 7); $cnt += 2; $this->pushInfo(7, $val, "2 digits ($d1,$d2) in MODE_NUMERIC"); } elseif ($digitsleft == 1) { $val = ($d1=$this->iData->Get()); Utils::Word2Bits($val, $tmpbits, 4); $cnt += 1; $this->pushInfo(4, $d1, "1 digit ($d1) in MODE_NUMERIC"); } $bits = array_merge($bits, $tmpbits); $digitsleft = $this->iData->Remaining(DataStorage::DIGIT); } $this->StoreBitsAndCounter($cnt,$bits,QREncoder::MODE_NUMERIC); $alnumleft = $this->iData->Remaining(DataStorage::ALPHANUM); $byteleft = $this->iData->Remaining(DataStorage::BYTEUNIQUE); if( $byteleft > 0 ) $nextmode = QREncoder::MODE_BYTE; elseif( $alnumleft > 0 ) $nextmode = QREncoder::MODE_ALPHANUM; else $nextmode = QREncoder::MODE_TERMINATOR; return $nextmode; } function encodeAlphaNum($aGreedy = true) { $cnt = 0; $bits = array(); $this->iInfo = array(); $alnumleft = $this->iData->Remaining(DataStorage::ALPHANUM); $switchbyte = $switchnumeric = false; while ( $alnumleft > 0 && !$switchbyte && !$switchnumeric ) { $tmpbits = array(); if ($alnumleft >= 2) { $c1 = $this->iData->GetVal(); $val = $this->iAlphaNumTable[$c1] * 45; $c2 = $this->iData->GetVal(); $val += $this->iAlphaNumTable[$c2]; Utils::Word2Bits($val, $tmpbits, 11); $cnt += 2; $this->pushInfo(11, $val, "2 characters (".chr($c1).",".chr($c2).") in MODE_ALPHANUM"); } else { $c1 = $this->iData->GetVal(); $val = $this->iAlphaNumTable[$c1]; Utils::Word2Bits($val, $tmpbits, 6); $cnt += 1; $this->pushInfo(6, $val, "1 character (".chr($c1).") in MODE_ALPHANUM"); } $bits = array_merge($bits, $tmpbits); if( !$aGreedy ) { $switchbyte = $this->iData->Remaining(DataStorage::BYTEUNIQUE) >= 1; $switchnumeric = $this->iData->Remaining(DataStorage::DIGIT) >= 13; } $alnumleft = $this->iData->Remaining(DataStorage::ALPHANUM); } $this->StoreBitsAndCounter($cnt,$bits,QREncoder::MODE_ALPHANUM); if( $switchbyte ) $nextmode = QREncoder::MODE_BYTE; elseif( $switchnumeric ) $nextmode = QREncoder::MODE_NUMERIC; else $nextmode = QREncoder::MODE_TERMINATOR; return $nextmode; } function encodeByte($aGreedy = true) { $cnt = 0; $bits = array(); $this->iInfo = array(); $bytesleft = $this->iData->Remaining(DataStorage::BYTE); $switchalnum = $switchnumeric = false; while ( $bytesleft > 0 && !$switchalnum && !$switchnumeric ) { $val = $this->iData->GetVal(); $tmpbits = array(); Utils::Word2Bits($val, $tmpbits, 8); ++$cnt; $hval = sprintf('%02x', $val); $this->pushInfo(11, $val, "1 byte ($val = $hval) in MODE_BYTE"); $bits = array_merge($bits, $tmpbits); if( !$aGreedy ) { $switchalnum = $this->iData->Remaining(DataStorage::ALPHA) >= 11; $switchnumeric = $this->iData->Remaining(DataStorage::DIGIT) >= 6; } $bytesleft = $this->iData->Remaining(DataStorage::BYTE); } $this->StoreBitsAndCounter($cnt,$bits,QREncoder::MODE_BYTE); if( $switchnumeric ) $nextmode = QREncoder::MODE_NUMERIC; elseif( $switchalnum ) $nextmode = QREncoder::MODE_ALPHANUM; else $nextmode = QREncoder::MODE_TERMINATOR; return $nextmode; } function StoreBitsAndCounter($aCnt,&$aBits,$aMode) { $cntBits = array(); Utils::Word2Bits($aCnt, $cntBits, $this->getCountBits($aMode)); $this->PutBitSequence($this->iModeIndicator[$aMode]); $this->PutBitSequence($cntBits); $this->PutBitSequence($aBits); $this->pushEncodeInfo(4, implode($this->iModeIndicator[$aMode]), $this->iModeIndicatorString[$aMode]); $this->pushEncodeInfo($this->getCountBits($aMode), implode($cntBits), "Counter (=$aCnt)"); $b = implode($aBits); if(strlen($b) > 15) { $b = substr($b, 0, 15) . '... '; } $this->pushEncodeInfo(count($aBits), $b, 'Bit sequence for '.$this->iModeIndicatorString[$aMode]); $ni = count($this->iInfo); for($i = 0; $i < $ni; ++$i) { $b = array(); Utils::Word2Bits($this->iInfo[$i][1], $b, $this->iInfo[$i][0]); $this->pushEncodeInfo($this->iInfo[$i][0], '(' . implode($b) . ')', $this->iInfo[$i][2]); } } function putBitSequence(&$aBitSeq) { $this->iSymbolBitArray = array_merge($this->iSymbolBitArray, $aBitSeq); $this->iSymbolBitArrayLen += count($aBitSeq); } } class DataStorage { const DIGIT = 1; const ALPHANUM = 2; const ALPHA = 3; const BYTE = 4; const BYTEUNIQUE = 5; const KANJI = 6; private $iData = array(), $iDataLen = 0, $iDataIdx = 0; function __construct($aData) { if(is_string($aData)) { $this->iData = str_split($aData); } else { $this->iData = $aData; } $this->iDataLen = count($this->iData); $this->iDataIdx = 0; } function __toString() { return implode($this->iData); } function Init() { $this->iDataIdx = 0; } function Len() { return $this->iDataLen; } function isDigit($aChar) { return ctype_digit($aChar); } function isAlnum($aChar) { return ctype_digit($aChar) || $this->isAlpha($aChar); } function isAlpha($aChar) { $found = strpos('ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-/:', $aChar); if( $found === false ) return false; else return true; } function isByte($aChar, $aUnique = false) { if(!$aUnique) { return ord($aChar) < 256; } else { return ord($aChar) < 256 && !$this->isAlnum($aChar); } } function Remaining($aType = null) { if($aType === null) { return $this->iDataLen - $this->iDataIdx ; } $idx = $this->iDataIdx; switch($aType) { case DataStorage::DIGIT: while($idx < $this->iDataLen && $this->isDigit($this->iData[$idx])) ++$idx; break; case DataStorage::ALPHANUM: while($idx < $this->iDataLen && $this->isAlnum($this->iData[$idx])) ++$idx; break; case DataStorage::ALPHA: while($idx < $this->iDataLen && $this->isAlpha($this->iData[$idx])) ++$idx; break; case DataStorage::BYTE: while($idx < $this->iDataLen && $this->isByte($this->iData[$idx])) ++$idx; break; case DataStorage::BYTEUNIQUE: while($idx < $this->iDataLen && $this->isByte($this->iData[$idx], true)) ++$idx; break; case DataStorage::KANJI: throw new QRExceptionL(1423); break; default: throw new QRExceptionL(1424,$aType); break; } return $idx - $this->iDataIdx ; } function isEnd() { return $this->iDataIdx >= $this->iDataLen; } function GetSlice($aLen, $aType = null) { $l = $this->Remaining($aType); if($aLen > $l) { throw new QRExceptionL(1425,$aLen,$aType,$l); } $d = array(); for($i = 0; $i < $aLen; ++$i) { $d[$i] = $this->iData[$this->iDataIdx++] ; } return $d; } function GetVal($aType = null) { return ord($this->Get($aType)); } function Get($aType = null) { if ($this->iDataIdx >= $this->iDataLen) { throw new QRExceptionL(1426); } else { if($aType === null) { return $this->iData[$this->iDataIdx++]; } else { $c = $this->iData[$this->iDataIdx++]; switch($aType) { case DataStorage::DIGIT: if($this->isDigit($c)) return $c; break; case DataStorage::ALPHANUM: if($this->isAlnum($c)) return $c; break; case DataStorage::BYTEUNIQUE: if($this->isByte($c, true)) return $c; break; case DataStorage::BYTE: if($this->isByte($c)) return $c; break; default: throw new QRExceptionL(1427,ord($c)); break; } } } } function Peek($aLookAhead = 0) { if ($this->iDataIdx + $aLookAhead >= $this->iDataLen) { throw new QRExceptionL(1428); } else { return $this->iData[$this->iDataIdx + $aLookAhead]; } } } ?>
