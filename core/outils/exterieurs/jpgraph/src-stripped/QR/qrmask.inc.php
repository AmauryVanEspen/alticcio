<?php
 class QRMask { private $iDbgInfo = '', $iDbgLevel = 0 ; private $iModuleCheckBlack = true; private static $iInstance; private function __construct() { } function SetDebugLevel($aLevel) { $this->iDbgLevel = $aLevel; } public static function getInstance() { if( !isset(self::$iInstance) ) { $c = __CLASS__; self::$iInstance = new $c(); } return self::$iInstance; } function __toString() { $tmp = $this->iDbgInfo; $this->iDbgInfo = ''; return $tmp; } function _dbgInfo($aLevel, $aString) { if ($aLevel <= $this->iDbgLevel) { $this->iDbgInfo .= $aString; } } function _printmatrix(&$aLayout) { if( $this->iDbgLevel < 3 ) return; $n = count($aLayout); $this->_dbgInfo(3, "n=$n\n"); $this->iDbgInfo .= ' '; for($j = 0; $j < $n; ++$j) { $this->_dbgInfo(3, $j%10 ); } $this->_dbgInfo(2, "\n"); for($i = 0; $i < $n; ++$i) { $this->_dbgInfo(3, $i%10 ); for($j = 0; $j < $n; ++$j) { $this->_dbgInfo(3, $this->_isColor($aLayout[$i][$j]) ? 'X' : '-'); } $this->_dbgInfo(3, "\n"); } $this->_dbgInfo(3, "\n"); } function _getModule(&$aLayout, $aRow, $aCol, $aFlip = false) { if ($aFlip) { return $aLayout[$aCol][$aRow]; } else { return $aLayout[$aRow][$aCol]; } } function _isColor($aVal) { if ( $this->iModuleCheckBlack ) { return $aVal != QRMatrixLayout::ZERO && $aVal != QRMatrixLayout::QUIET ; } else { return $aVal == QRMatrixLayout::ZERO || $aVal == QRMatrixLayout::QUIET; } } function _isRCSet(&$aLayout, $aRow, $aCol, $aFlip = false) { if ($aFlip) { $val = $aLayout[$aCol][$aRow]; } else { $val = $aLayout[$aRow][$aCol]; } if ( $this->iModuleCheckBlack ) { return $val != QRMatrixLayout::ZERO && $val != QRMatrixLayout::QUIET ; } else { return $val == QRMatrixLayout::ZERO || $val == QRMatrixLayout::QUIET ; } } function _evalLines(&$aLayout, $n, $aFlip = false) { $this->_dbgInfo(2, "\nLINE SEARCH\n"); $hy = 0; $inseq = false; $cnt = 0; $vx = $vy = 0; $score = 0; $np = 5 ; for($x = 0; $x < $n; ++$x) { for($y = 0; $y < $n; ++$y) { if ($this->_isRCSet($aLayout, $y, $x, $aFlip)) { ++$cnt; if (!$inseq) { $vx = $x; $vy = $y; } $inseq = true; } else { if ($inseq) { $inseq = false; if ($cnt >= $np) { $score += (3 + $cnt-$np); if ($aFlip) { $this->_dbgInfo(3, " Horizontal stretch at ($vx,$vy) len=$cnt (Acc score=$score)\n"); } else { $this->_dbgInfo(3, " Vertical stretch at ($vy,$vx) len=$cnt (Acc score=$score)\n"); } } $cnt = 0; } } } if ($inseq) { $inseq = false; if ($cnt >= $np) { $score += (3 + $cnt-$np); if ($aFlip) { $this->_dbgInfo(3, " Horizontal stretch at ($vx,$vy) len=$cnt (Acc score=$score)\n"); } else { $this->_dbgInfo(3, " Vertical stretch at ($vy,$vx) len=$cnt (Acc score=$score)\n"); } } $cnt = 0; } } return $score; } function _eval11311Pattern(&$aLayout, $n, $aFlip = false) { $augLayout = array(); for($i=0; $i < $n+2; ++$i) { $augLayout[$i] = array_fill(0,$n+2,QRMatrixLayout::QUIET); if( $i > 0 && $i <= $n ) array_splice($augLayout[$i],1,$n,$aLayout[$i-1]); } $n += 2; $pattern = array(false,true, false, true, true, true, false, true, false); $score = 0; $np = count($pattern); $this->_dbgInfo(3, "\nPATTERN SEARCH (1:1:3:1:1)\n"); $vx = $vy = 0; for($x = 0; $x < $n; ++$x) { $y = 0; $idx = 0; $inseq = false; while ($y < $n) { if (! ($this->_isRCSet($augLayout, $y, $x, $aFlip) ^ $pattern[$idx])) { if ($inseq) { if ($idx < $np-1) { ++$idx; } else { $idx = 0; $inseq = false; $score += 40; if ($aFlip) { $this->_dbgInfo(3, "  Horizontal Pattern at ($vx,$vy) (Acc score=$score)\n"); } else { $this->_dbgInfo(3, "  Vertical Pattern at ($vy,$vx) (Acc score=$score)\n"); } } } else { $inseq = true; $vx = $x; $vy = $y; ++$idx; } ++$y; } else { if ($inseq) { $inseq = false; $idx = 0; $y = $vy + 1; } else { ++$y; } } if( !$inseq && $y > $n-$np ) { $y = $n; } } } return $score; } function _evalProp(&$aLayout, $n) { $this->_dbgInfo(3, "\nEvaluating Proportion as "); $cnt = 0; for($y = 0; $y < $n; ++$y) { for($x = 0; $x < $n; ++$x) { $cnt += $this->_isColor($aLayout[$y][$x]) ? 1 : 0; } } $p = round($cnt * 100 / ($n * $n)); $score = 10*floor(abs($p-50) / 5); $this->_dbgInfo(3, "  p=$p% color => score=$score\n"); return $score; } function _evalBlock($aLayout, $n, $aFlip = false) { $this->_dbgInfo(3, "\nBLOCK SEARCH\n"); $score = 0 ; for($y = 0; $y < $n; ++$y) { for($x = 0; $x < $n; $x += $width) { $width = 1; if ($this->_isRCSet($aLayout, $y, $x, $aFlip)) { $xx = $x + 1; $yy = $y; while ($xx < $n && $this->_isRCSet($aLayout, $yy, $xx, $aFlip)) { ++$width; ++$xx; } if ($width > 1) { $this->_dbgInfo(4, "  Found block stretch at ($y,$x) of len=$width\n"); $height = 1; ++$yy; $xx = $x; $currwidth=1000; while ($yy < $n && $currwidth>1 && $this->_isRCSet($aLayout, $yy, $xx, $aFlip)) { ++$height; $currwidth = 0; while ($xx < $n && $this->_isRCSet($aLayout, $yy, $xx, $aFlip)) { ++$currwidth; ++$xx; } $this->_dbgInfo(4, "     Found block stretch at ($yy,$x) of len=$currwidth, height=$height\n"); if ($currwidth < $width && $height > 2) { $yy = $n; --$height; } else { if( $currwidth == 1 ) { --$height; $yy = $n; } else { $width = min($width, $currwidth); ++$yy; $xx = $x; } } } if ($height > 1) { $score += 3*($height-1) * ($width-1); $this->_dbgInfo(3, "  Found block at ($y,$x) of size ($height x $width) (Acc score:$score)\n"); $val = $this->iModuleCheckBlack ? QRMatrixLayout::ZERO : QRMatrixLayout::ONE; for($ii = 0; $ii < $height; ++$ii) { for($jj = 0; $jj < $width; ++$jj) { $aLayout[$ii + $y][$jj + $x] = $val; } } } else { $width = 1; } } } } } return $score; } function evaluate(&$aLayout,$maskIdx=-1) { $n = count($aLayout); $score = 0; $this->_dbgInfo(3, "\n Evaluating Mask index = $maskIdx\n"); $this->iModuleCheckBlack = true; $this->_printmatrix($aLayout); $this->_dbgInfo(3, "\n-- Evaluating BLACK MODULES --\n"); $score += $this->_evalLines($aLayout, $n, false); $score += $this->_evalLines($aLayout, $n, true); $score += $this->_eval11311Pattern($aLayout, $n, false); $score += $this->_eval11311Pattern($aLayout, $n, true); $score += $this->_evalProp($aLayout, $n); $score += $this->_evalBlock($aLayout, $n, false); $this->_dbgInfo(3, "\n-- Evaluating WHITE MODULES --\n"); $this->iModuleCheckBlack = false; $score += $this->_evalLines($aLayout, $n, false); $score += $this->_evalLines($aLayout, $n, true); $score += $this->_evalBlock($aLayout, $n, false); return $score; } function _mask($aMask, $i, $j, $aVal) { switch ($aMask) { case 0: $mask = ($i + $j) % 2 == 0 ; break; case 1: $mask = ($i % 2) == 0 ; break; case 2: $mask = ($j % 3) == 0 ; break; case 3: $mask = (($i + $j) % 3) == 0 ; break; case 4: $mask = (floor($i / 2) + floor($j / 3)) % 2 == 0 ; break; case 5: $mask = ($i * $j) % 2 + ($i * $j) % 3 == 0 ; break; case 6: $mask = (($i * $j) % 2 + ($i * $j) % 3) % 2 == 0 ; break; case 7: $mask = (($i * $j) % 3 + ($i + $j) % 2) % 2 == 0 ; break; default: throw new QRExceptionL(1100); break; } if ($mask) { if( $aVal == QRMatrixLayout::ONE || $aVal == QRMatrixLayout::ZERO ) { return $aVal == QRMatrixLayout::ONE ? QRMatrixLayout::ZERO : QRMatrixLayout::ONE; } else { throw new QRExceptionL(1101); } } else return $aVal; } function applyMask(&$aLayout, $aMask) { $n = count($aLayout); for($i = 0; $i < $n; ++$i) { for($j = 0; $j < $n; ++$j) { $v = $aLayout[$i][$j]; if ($v == QRMatrixLayout::ZERO || $v == QRMatrixLayout::ONE) { $aLayout[$i][$j] = $this->_mask($aMask, $i, $j, $v) ; } elseif ($aLayout[$i][$j] == QRMatrixLayout::UNINIT) { throw new QRExceptionL(1102); } } } } } ?>
