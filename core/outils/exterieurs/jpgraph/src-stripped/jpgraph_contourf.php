<?php
 require_once('jpgraph_meshinterpolate.inc.php'); class ContourWorker { public $nContours=-1, $contval = array(), $contcolors = array(); public $contlinecolor='black'; public $showcontlines=true; public $fillContour=false; public $showtriangulation=false,$triangulation_color="lightgray"; private $data=array(), $nRows=-1, $nCols=-1; private $maxdepth=6; private $labels = array(), $showlabels=false; private $labelColor='black',$labelFF=FF_ARIAL,$labelFS=FS_BOLD,$labelFSize=10; private $angledLabels=true; private $extendedcollisioncheck=false; private $highcontrast=false,$highcontrastbw=false; private $invert=false; function __construct($aData,$aContours=10) { if( is_array($aContours) ) { $this->nContours = count($aContours); $this->contval = $aContours; } else { $this->nContours = $aContours; $this->contval = array(); } $this->data = $aData; $this->nRows = count($aData); $this->nCols = count($aData[0]); } function SetContours($aContours) { $this->contval = $aContours; } function SetContColors($aColors) { $this->contcolors = $aColors; } function SetFont($aFFamily,$aFStyle=FS_NORMAL,$aFSize=10) { $this->labelFF = $aFFamily; $this->labelFS = $aFStyle; $this->labelFSize = $aFSize; } function SetFontColor($aColor) { $this->labelColor = $aColor; } function GetMinMaxVal() { $min = $this->data[0][0]; $max = $this->data[0][0]; for ($i = 0; $i < $this->nRows; $i++) { if( ($mi=min($this->data[$i])) < $min ) $min = $mi; if( ($ma=max($this->data[$i])) > $max ) $max = $ma; } return array($min,$max); } function UseHighContrastColor($aFlg=true,$aBW=false) { $this->highcontrast = $aFlg; $this->highcontrastbw = $aBW; } function CalculateColors() { if ( $this->highcontrast ) { if ( $this->highcontrastbw ) { for ($ib = 0; $ib <= $this->nContours; $ib++) { $this->contcolors[$ib] = 'black'; } } else { $step = 255.0/$this->nContours; for ($ib = 0; $ib <= $this->nContours; $ib++) { $this->contcolors[$ib] = array(round($ib*$step), 50, round(255-$ib*$step)); } } } else { $n = $this->nContours; $v = 0; $step = 1 / ($this->nContours); for ($ib = 0; $ib <= $this->nContours; $ib++) { $this->contcolors[$ib] = RGB::GetSpectrum($v); $v += $step; } } } function SetMaxSearchDepth($aDepth) { $this->maxdepth = $aDepth; } function ShowLabels($aFlg=true,$aAngledLabels=true) { $this->showlabels = $aFlg; $this->angledLabels = $aAngledLabels; } function ShowLines($aFlg=true,$aColorWhenFilled='black') { $this->showcontlines=$aFlg; $this->contlinecolor=$aColorWhenFilled; } function SetFilled($aFlg=true) { $this->fillContour = $aFlg; } function SetInvert($aFlg=true) { $this->invert = $aFlg; } function ShowTriangulation($aFlg=true) { $this->showtriangulation = $aFlg; } function Translate(&$p) { $n = count($p); for ($i = 0 ; $i < $n ; $i += 2) { $p[$i] = $this->xscale->Translate($p[$i]); $p[$i+1] = $this->yscale->Translate($p[$i+1]); } } function Line($aColor,&$p) { $this->Translate($p); $this->img->SetColor($aColor); $this->img->Line($p[0],$p[1],$p[2],$p[3]); } function FillPolygon($color,&$p) { $this->Translate($p); if( $this->fillContour ) { $this->img->SetColor($color); $this->img->FilledPolygon($p); } if( $this->showtriangulation ) { $this->img->SetColor($this->triangulation_color); $this->img->Polygon($p); } } function GetNextHigherContourIdx($val) { for( $i=0; $i < count($this->contval); ++$i ) { if( $val < $this->contval[$i] ) return $i; } return count($this->contval); } function GetContVal($aVal) { for( $i=0; $i < count($this->contval); ++$i ) { if( $aVal < $this->contval[$i] ) { return $this->contval[$i]; } } JpGraphError::RaiseL($errnbr); } function GetColor($aVal) { return $this->contcolors[$this->GetNextHigherContourIdx($aVal)]; } function LabelProx($x1,$y1,$v1) { $w = $this->img->plotwidth+$this->img->left_margin; $h = $this->img->plotheight+$this->img->top_margin; if( $x1 < 30 || $x1 > $w-20 ) return true; if( $y1 < 20 || $y1 > $h-20 ) return true; $idx = $this->GetNextHigherContourIdx($v1); if( !isset ($this->labels[$idx]) ) { return false; } $p = $this->labels[$idx]; $n = count($p); $d = 9999999; for ($i = 0 ; $i < $n ; $i++) { $xp = $p[$i][0]; $yp = $p[$i][1]; $d = min($d, ($x1-$xp)*($x1-$xp) + ($y1-$yp)*($y1-$yp)); } $d2 = 9999999; $d3 = 9999999; if( $this->extendedcollisioncheck ) { if( $idx < count($this->labels)-1 && isset($this->labels[$idx+1]) ) { $p = $this->labels[$idx+1]; $n = count($p); for ($i = 0 ; $i < $n ; $i++) { $xp = $p[$i][0]; $yp = $p[$i][1]; $d2 = min($d2, ($x1-$xp)*($x1-$xp) + ($y1-$yp)*($y1-$yp)); } } if( $idx > 0 && isset($this->labels[$idx-1]) ) { $p = $this->labels[$idx-1]; $n = count($p); for ($i = 0 ; $i < $n ; $i++) { $xp = $p[$i][0]; $yp = $p[$i][1]; $d3 = min($d3, ($x1-$xp)*($x1-$xp) + ($y1-$yp)*($y1-$yp)); } } } $limit = $w*$h/9; $limit = max(min($limit,10000),3000); if( $d2 < $limit/3 || $d3 < $limit/3 || $d < $limit/2 ) { return true; } else { return false; } } function PutLabel($x1,$y1,$x2,$y2,$v1) { $angle = 0; if( $x2 - $x1 != 0 ) { $grad = ($y2-$y1)/($x2-$x1); $angle = -(atan($grad) * 180/M_PI); } if( !$this->LabelProx($x1, $y1, $v1) ) { $this->labels[$this->GetNextHigherContourIdx($v1)][] = array($x1,$y1,$v1,$angle); } } function StrokeLabels() { $t = new Text(); $t->SetColor($this->labelColor); $t->SetFont($this->labelFF,$this->labelFS,$this->labelFSize); $t->SetAlign('center','center'); foreach ($this->labels as $cont_idx => $pos) { foreach ($pos as $idx => $coord) { $t->Set( sprintf("%.1f",$coord[2]) ); if( $this->angledLabels ) $t->SetAngle($coord[3]); $t->Stroke($this->img,$coord[0],$coord[1]); } } } function Pertubate(&$v1,&$v2,&$v3,&$v4) { $pert = 0.9999; $n = count($this->contval); for($i=0; $i < $n; ++$i) { if( $v1==$this->contval[$i] ) { $v1 *= $pert; break; } } for($i=0; $i < $n; ++$i) { if( $v2==$this->contval[$i] ) { $v2 *= $pert; break; } } for($i=0; $i < $n; ++$i) { if( $v3==$this->contval[$i] ) { $v3 *= $pert; break; } } for($i=0; $i < $n; ++$i) { if( $v4==$this->contval[$i] ) { $v4 *= $pert; break; } } } function interp2($x1,$y1,$x2,$y2,$v1,$v2) { $cv = $this->GetContVal(min($v1,$v2)); $alpha = ($v1-$cv)/($v1-$v2); $x1p = $x1*(1-$alpha) + $x2*$alpha; $y1p = $y1*(1-$alpha) + $y2*$alpha; $v1p = $v1 + $alpha*($v2-$v1); return array($x1p,$y1p,$v1p); } function RectFill($v1,$v2,$v3,$v4,$x1,$y1,$x2,$y2,$x3,$y3,$x4,$y4,$depth) { if( $depth > $this->maxdepth ) { $color = $this->GetColor(($v1+$v2+$v3+$v4)/4); $p = array($x1, $y1, $x2, $y2, $x3, $y3, $x4, $y4, $x1, $y1); $this->FillPolygon($color,$p) ; } else { $this->Pertubate($v1,$v2,$v3,$v4); $fcnt = 0 ; $vv1 = $this->GetNextHigherContourIdx($v1); $vv2 = $this->GetNextHigherContourIdx($v2); $vv3 = $this->GetNextHigherContourIdx($v3); $vv4 = $this->GetNextHigherContourIdx($v4); $eps = 0.0001; if( $vv1 == $vv2 && $vv2 == $vv3 && $vv3 == $vv4 ) { $color = $this->GetColor($v1); $p = array($x1, $y1, $x2, $y2, $x3, $y3, $x4, $y4, $x1, $y1); $this->FillPolygon($color,$p) ; } else { $dv1 = abs($vv1-$vv2); $dv2 = abs($vv2-$vv3); $dv3 = abs($vv3-$vv4); $dv4 = abs($vv1-$vv4); if( $dv1 == 1 ) { list($x1p,$y1p,$v1p) = $this->interp2($x1,$y1,$x2,$y2,$v1,$v2); $fcnt++; } if( $dv2 == 1 ) { list($x2p,$y2p,$v2p) = $this->interp2($x2,$y2,$x3,$y3,$v2,$v3); $fcnt++; } if( $dv3 == 1 ) { list($x3p,$y3p,$v3p) = $this->interp2($x3,$y3,$x4,$y4,$v3,$v4); $fcnt++; } if( $dv4 == 1 ) { list($x4p,$y4p,$v4p) = $this->interp2($x4,$y4,$x1,$y1,$v4,$v1); $fcnt++; } $totdv = $dv1 + $dv2 + $dv3 + $dv4 ; if( ($fcnt == 2 && $totdv==2) || ($fcnt == 4 && $totdv==4) ) { if( $fcnt == 2 && $totdv==2 ) { if( $dv1 == 1 && $dv2 == 1) { $color1 = $this->GetColor($v2); $p1 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x1p,$y1p); $color2 = $this->GetColor($v4); $p2 = array($x1,$y1,$x1p,$y1p,$x2p,$y2p,$x3,$y3,$x4,$y4,$x1,$y1); $color = $this->GetColor($v1p); $p = array($x1p,$y1p,$x2p,$y2p); $v = $v1p; } elseif( $dv1 == 1 && $dv3 == 1 ) { $color1 = $this->GetColor($v2); $p1 = array($x1p,$y1p,$x2,$y2,$x3,$y3,$x3p,$y3p,$x1p,$y1p); $color2 = $this->GetColor($v4); $p2 = array($x1,$y1,$x1p,$y1p,$x3p,$y3p,$x4,$y4,$x1,$y1); $color = $this->GetColor($v1p); $p = array($x1p,$y1p,$x3p,$y3p); $v = $v1p; } elseif( $dv1 == 1 && $dv4 == 1 ) { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x1p,$y1p,$x4p,$y4p,$x1,$y1); $color2 = $this->GetColor($v3); $p2 = array($x1p,$y1p,$x2,$y2,$x3,$y3,$x4,$y4,$x4p,$y4p,$x1p,$y1p); $color = $this->GetColor($v1p); $p = array($x1p,$y1p,$x4p,$y4p); $v = $v1p; } elseif( $dv2 == 1 && $dv4 == 1 ) { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x2,$y2,$x2p,$y2p,$x4p,$y4p,$x1,$y1); $color2 = $this->GetColor($v3); $p2 = array($x4p,$y4p,$x2p,$y2p,$x3,$y3,$x4,$y4,$x4p,$y4p); $color = $this->GetColor($v2p); $p = array($x2p,$y2p,$x4p,$y4p); $v = $v2p; } elseif( $dv2 == 1 && $dv3 == 1 ) { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x2,$y2,$x2p,$y2p,$x3p,$y3p,$x4,$y4,$x1,$y1); $color2 = $this->GetColor($v3); $p2 = array($x2p,$y2p,$x3,$y3,$x3p,$y3p,$x2p,$y2p); $color = $this->GetColor($v2p); $p = array($x2p,$y2p,$x3p,$y3p); $v = $v2p; } elseif( $dv3 == 1 && $dv4 == 1 ) { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x2,$y2,$x3,$y3,$x3p,$y3p,$x4p,$y4p,$x1,$y1); $color2 = $this->GetColor($v4); $p2 = array($x4p,$y4p,$x3p,$y3p,$x4,$y4,$x4p,$y4p); $color = $this->GetColor($v4p); $p = array($x4p,$y4p,$x3p,$y3p); $v = $v4p; } $this->FillPolygon($color1,$p1); $this->FillPolygon($color2,$p2); if( $this->showcontlines ) { if( $this->fillContour) { $this->Line($this->contlinecolor,$p); } else { $this->Line($color,$p); } } if( $this->showlabels ) { if( !$this->showcontlines ) { $this->Translate($p); } $this->PutLabel( ($p[0]+$p[2])/2, ($p[1]+$p[3])/2, $p[2],$p[3] , $v); } } elseif( $fcnt == 4 && $totdv==4 ) { $vc = ($v1+$v2+$v3+$v4)/4; if( $v1p == $v2p && $v2p == $v3p && $v3p == $v4p ) { if( $this->GetNextHigherContourIdx($vc) == $this->GetNextHigherContourIdx($v1) ) { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x1p,$y1p,$x4p,$y4p,$x1,$y1); $color2 = $this->GetColor($v2); $p2 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x3p,$y3p,$x4,$y4,$x4p,$y4p,$x1p,$y1p); $color3 = $color1; $p3 = array($x2p,$y2p,$x3,$y3,$x3p,$y3p,$x2p,$y2p); $colorl1 = $this->GetColor($v1p); $pl1 = array($x1p,$y1p,$x4p,$y4p); $colorl2 = $this->GetColor($v2p); $pl2 = array($x2p,$y2p,$x3p,$y3p); $vl1 = $v1p; $vl2 = $v2p; } else { $color1 = $this->GetColor($v2); $p1 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x1p,$y1p); $color2 = $this->GetColor($v3); $p2 = array($x1p,$y1p,$x2p,$y2p,$x3,$y3,$x3p,$y3p,$x4p,$y4p,$x1,$y1,$x1p,$y1p); $color3 = $color1; $p3 = array($x4p,$y4p,$x3p,$y3p,$x4,$y4,$x4p,$y4p); $colorl1 = $this->GetColor($v1p); $pl1 = array($x1p,$y1p,$x2p,$y2p); $colorl2 = $this->GetColor($v4p); $pl2 = array($x4p,$y4p,$x3p,$y3p); $vl1 = $v1p; $vl2 = $v4p; } } else { if( $v1p == $v2p ) { $color1 = $this->GetColor($v2); $p1 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x1p,$y1p); $color2 = $this->GetColor($v3); $p2 = array($x1p,$y1p,$x2p,$y2p,$x3,$y3,$x3p,$y3p,$x4p,$y4p,$x1,$y1,$x1p,$y1p); $color3 = $this->GetColor($v4); $p3 = array($x4p,$y4p,$x3p,$y3p,$x4,$y4,$x4p,$y4p); $colorl1 = $this->GetColor($v1p); $pl1 = array($x1p,$y1p,$x2p,$y2p); $colorl2 = $this->GetColor($v4p); $pl2 = array($x4p,$y4p,$x3p,$y3p); $vl1 = $v1p; $vl2 = $v4p; } else { $color1 = $this->GetColor($v1); $p1 = array($x1,$y1,$x1p,$y1p,$x4p,$y4p,$x1,$y1); $color2 = $this->GetColor($v2); $p2 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x3p,$y3p,$x4,$y4,$x4p,$y4p,$x1p,$y1p); $color3 = $this->GetColor($v3); $p3 = array($x2p,$y2p,$x3,$y3,$x3p,$y3p,$x2p,$y2p); $colorl1 = $this->GetColor($v1p); $pl1 = array($x1p,$y1p,$x4p,$y4p); $colorl2 = $this->GetColor($v2p); $pl2 = array($x2p,$y2p,$x3p,$y3p); $vl1 = $v1p; $vl2 = $v2p; } } $this->FillPolygon($color1,$p1); $this->FillPolygon($color2,$p2); $this->FillPolygon($color3,$p3); if( $this->showcontlines ) { if( $this->fillContour ) { $this->Line($this->contlinecolor, $pl1); $this->Line($this->contlinecolor, $pl2); } else { $this->Line($colorl1, $pl1); $this->Line($colorl2, $pl2); } } if( $this->showlabels ) { if( !$this->showcontlines ) { $this->Translate($pl1); $this->Translate($pl2); } $this->PutLabel( ($pl1[0]+$pl1[2])/2, ($pl1[1]+$pl1[3])/2, $pl1[2], $pl1[3], $vl1); $this->PutLabel( ($pl2[0]+$pl2[2])/2, ($pl2[1]+$pl2[3])/2, $pl2[2], $pl2[3],$vl2); } } } else { $vc = ($v1+$v2+$v3+$v4)/4; $xc = ($x1+$x4)/2; $yc = ($y1+$y2)/2; $this->RectFill(($v1+$v2)/2, $v2, ($v2+$v3)/2, $vc, $x1,$yc, $x2,$y2, $xc,$y2, $xc,$yc, $depth+1); $this->RectFill($vc, ($v2+$v3)/2, $v3, ($v3+$v4)/2, $xc,$yc, $xc,$y2, $x3,$y3, $x3,$yc, $depth+1); $this->RectFill($v1, ($v1+$v2)/2, $vc, ($v1+$v4)/2, $x1,$y1, $x1,$yc, $xc,$yc, $xc,$y4, $depth+1); $this->RectFill(($v1+$v4)/2, $vc, ($v3+$v4)/2, $v4, $xc,$y1, $xc,$yc, $x3,$yc, $x4,$y4, $depth+1); } } } } function TriFill($v1,$v2,$v3,$x1,$y1,$x2,$y2,$x3,$y3,$depth) { if( $depth > $this->maxdepth ) { $color = $this->GetColor(($v1+$v2+$v3)/3); $p = array($x1, $y1, $x2, $y2, $x3, $y3, $x1, $y1); $this->FillPolygon($color,$p) ; } else { $dummy=0; $this->Pertubate($v1,$v2,$v3,$dummy); $fcnt = 0 ; $vv1 = $this->GetNextHigherContourIdx($v1); $vv2 = $this->GetNextHigherContourIdx($v2); $vv3 = $this->GetNextHigherContourIdx($v3); $eps = 0.0001; if( $vv1 == $vv2 && $vv2 == $vv3 ) { $color = $this->GetColor($v1); $p = array($x1, $y1, $x2, $y2, $x3, $y3, $x1, $y1); $this->FillPolygon($color,$p) ; } else { $dv1 = abs($vv1-$vv2); $dv2 = abs($vv2-$vv3); $dv3 = abs($vv1-$vv3); if( $dv1 == 1 ) { list($x1p,$y1p,$v1p) = $this->interp2($x1,$y1,$x2,$y2,$v1,$v2); $fcnt++; } else { $x1p = ($x1+$x2)/2; $y1p = ($y1+$y2)/2; $v1p = ($v1+$v2)/2; } if( $dv2 == 1 ) { list($x2p,$y2p,$v2p) = $this->interp2($x2,$y2,$x3,$y3,$v2,$v3); $fcnt++; } else { $x2p = ($x2+$x3)/2; $y2p = ($y2+$y3)/2; $v2p = ($v2+$v3)/2; } if( $dv3 == 1 ) { list($x3p,$y3p,$v3p) = $this->interp2($x3,$y3,$x1,$y1,$v3,$v1); $fcnt++; } else { $x3p = ($x3+$x1)/2; $y3p = ($y3+$y1)/2; $v3p = ($v3+$v1)/2; } if( $fcnt == 2 && ((abs($v1p-$v2p) < $eps && $dv1 ==1 && $dv2==1 ) || (abs($v1p-$v3p) < $eps && $dv1 ==1 && $dv3==1 ) || (abs($v2p-$v3p) < $eps && $dv2 ==1 && $dv3==1 )) ) { if( abs($v1p-$v2p) < $eps ) { $p4 = array($x1,$y1,$x1p,$y1p,$x2p,$y2p,$x3,$y3,$x1,$y1); $color4 = $this->GetColor($v1); $p3 = array($x1p,$y1p,$x2,$y2,$x2p,$y2p,$x1p,$y1p); $color3 = $this->GetColor($v2); $p = array($x1p,$y1p,$x2p,$y2p); $color = $this->GetColor($v1p); $v = $v1p; } elseif( abs($v1p-$v3p) < $eps ) { $p4 = array($x1p,$y1p,$x2,$y2,$x3,$y3,$x3p,$y3p,$x1p,$y1p); $color4 = $this->GetColor($v2); $p3 = array($x1,$y1,$x1p,$y1p,$x3p,$y3p,$x1,$y1); $color3 = $this->GetColor($v1); $p = array($x1p,$y1p,$x3p,$y3p); $color = $this->GetColor($v1p); $v = $v1p; } else { $p4 = array($x1,$y1,$x2,$y2,$x2p,$y2p,$x3p,$y3p,$x1,$y1); $color4 = $this->GetColor($v2); $p3 = array($x3p,$y3p,$x2p,$y2p,$x3,$y3,$x3p,$y3p); $color3 = $this->GetColor($v3); $p = array($x3p,$y3p,$x2p,$y2p); $color = $this->GetColor($v3p); $v = $v3p; } $this->FillPolygon($color4,$p4); $this->FillPolygon($color3,$p3); if( $this->showcontlines ) { if( $this->fillContour ) { $this->Line($this->contlinecolor,$p); } else { $this->Line($color,$p); } } if( $this->showlabels ) { if( !$this->showcontlines ) { $this->Translate($p); } $this->PutLabel( ($p[0]+$p[2])/2, ($p[1]+$p[3])/2, $p[2], $p[3], $v); } } else { $this->TriFill($v1, $v1p, $v3p, $x1, $y1, $x1p, $y1p, $x3p, $y3p, $depth+1); $this->TriFill($v1p, $v2, $v2p, $x1p, $y1p, $x2, $y2, $x2p, $y2p, $depth+1); $this->TriFill($v3p, $v1p, $v2p, $x3p, $y3p, $x1p, $y1p, $x2p, $y2p, $depth+1); $this->TriFill($v3p, $v2p, $v3, $x3p, $y3p, $x2p, $y2p, $x3, $y3, $depth+1); } } } } function SetupContourValues() { if( is_array($this->contval) && count($this->contval) == 0 ) { list($min,$max) = $this->GetMinMaxVal(); $stepSize = ($max-$min) / $this->nContours ; $isobar = $min+$stepSize/2; for ($i = 0; $i < $this->nContours; $i++) { $this->contval[$i] = $isobar; $isobar += $stepSize; } } if( count($this->contcolors) == 0 ) { $this->CalculateColors(); } return array($this->contval,$this->contcolors); } function Fillmesh($img, $xscale, $yscale, $maxdepth, $method='tri') { $this->img = $img; $this->xscale = $xscale; $this->yscale = $yscale; $this->maxdepth = $maxdepth; $nc = $this->nContours+1; if( count($this->contcolors) != $nc ) { JpGraphError::RaiseL(28002); } for( $x=0; $x < $this->nCols-1; ++$x ) { for( $y=0; $y < $this->nRows-1; ++$y ) { if( $this->invert ) { $v1 = $this->data[$this->nRows-$y-1][$x]; $v2 = $this->data[$this->nRows-$y-1][$x+1]; $v3 = $this->data[$this->nRows-$y-2][$x+1]; $v4 = $this->data[$this->nRows-$y-2][$x]; } else { $v1 = $this->data[$y][$x]; $v2 = $this->data[$y][$x+1]; $v3 = $this->data[$y+1][$x+1]; $v4 = $this->data[$y+1][$x]; } if( $method == 'tri' ) { if( $this->invert ) { $this->TriFill($v3, $v4, $v1, $x+1, $y+1, $x, $y+1, $x, $y, 0); $this->TriFill($v3, $v1, $v2, $x+1, $y+1, $x, $y, $x+1, $y, 0); } else { $this->TriFill($v4, $v1, $v2, $x, $y+1, $x, $y, $x+1, $y, 0); $this->TriFill($v4, $v2, $v3, $x, $y+1, $x+1, $y, $x+1, $y+1, 0); } } else { $this->RectFill($v4, $v1, $v2, $v3, $x, $y+1, $x, $y, $x+1, $y, $x+1, $y+1, 0); } } } if( $this->showlabels ) { $this->StrokeLabels(); } } } class FilledContourPlot extends Plot { private $contourVal, $contourColor, $nbrCountours = 0 ; private $dataMatrix = array(); private $invertLegend = false; private $interpFactor = 1; private $flipData = false; private $showLegend=false; private $maxdepth=6; private $method='rect'; private $filled = false; private $cw = null; function __construct($aDataMatrix, $aIsobar=10, $aFactor=1, $aInvert=false, $aIsobarColors=array()) { $this->dataMatrix = $aDataMatrix; $this->flipData = $aInvert; $this->interpFactor = $aFactor; if ( $this->interpFactor > 1 ) { if( $this->interpFactor > 5 ) { JpGraphError::RaiseL(28007); } $ip = new MeshInterpolate(); $this->dataMatrix = $ip->Linear($this->dataMatrix, $this->interpFactor); } if( is_array($aIsobar) ) { $this->nbrContours = count($aIsobar); } else { $this->nbrContours = $aIsobar; } $this->cw = new ContourWorker($aDataMatrix,$aIsobar); $this->cw->SetContColors($aIsobarColors); $this->cw->SetInvert($aInvert); } function ShowLabels($aFlg=true,$aAngledLabels=true) { $this->cw->ShowLabels($aFlg,$aAngledLabels); } function SetFilled($aFlg=true) { $this->cw->SetFilled($aFlg); } function ShowTriangulation($aFlg=true) { $this->cw->ShowTriangulation($aFlg); } function ShowLines($aFlg=true,$aColorWhenFilled='black') { $this->cw->ShowLines($aFlg, $aColorWhenFilled); } function SetMethod($aMethod) { $this->method = $aMethod; } function SetInvert($aFlg=true) { $this->cw->SetInvert($aFlg); } function SetIsobarColors($aColorArray) { $this->cw->SetContColors($aColorArray); } function ShowLegend($aFlg=true) { $this->showLegend = $aFlg; } function Invertlegend($aFlg=true) { $this->invertLegend = $aFlg; } function Min() { return array(0,0); } function Max() { return array(count($this->dataMatrix[0])-1,count($this->dataMatrix)-1); } function Legend($aGraph) { if( ! $this->showLegend ) return; if( $aGraph->legend->font_family <= FF_FONT2+1 ) { $lte = "<="; } else { $lte = SymChar::Get('lte'); } if( $this->invertLegend ) { for ($i = 0; $i < $this->nbrContours; $i++) { $aGraph->legend->Add(sprintf($lte.' %.1f',$this->contourVal[$i]), $this->contourColor[$i]); } } else { for ($i = $this->nbrContours-1; $i >= 0 ; $i--) { $aGraph->legend->Add(sprintf($lte.' %.1f',$this->contourVal[$i]), $this->contourColor[$i]); } } } function SetFont($aFFamily,$aFStyle=FS_NORMAL,$aFSize=10) { $this->cw->SetFont($aFFamily, $aFStyle, $aFSize); } function SetFontColor($aColor) { $this->cw->SetFontColor($aColor); } function PreScaleSetup($aGraph) { $xn = count($this->dataMatrix[0])-1; $yn = count($this->dataMatrix)-1; $aGraph->xaxis->scale->Update($aGraph->img,0,$xn); $aGraph->yaxis->scale->Update($aGraph->img,0,$yn); list($this->contourVal,$this->contourColor) = $this->cw->SetupContourValues(); } function UseHighContrastColor($aFlg=true,$aBW=false) { $this->cw->UseHighContrastColor($aFlg,$aBW); } function Stroke($img,$xscale,$yscale) { $img->SetLineWeight($this->line_weight); $this->cw->Fillmesh($img, $xscale, $yscale, $this->maxdepth, $this->method); } } ?>
